import configureMockStore from "redux-mock-store";
import thunk from "redux-thunk";
import {
  startAddExpense,
  addExpense,
  editExpense,
  removeExpense
} from "../../actions/expenses";
import expenses from "../fixtures/expenses";
import database from "../../firebase/firebase";

const createMockStore = configureMockStore([thunk]);

test("should setup remove expense action object", () => {
  const action = removeExpense({ id: "123abc" });
  /* When we're using OBJECTS or ARRAYS we want to use the 'toEqual' method(coming from JEST) INSTEAD if we're
  using BOOLEAN, NUMBERS or STRINGS we want to use the 'toBe' method */
  expect(action).toEqual({
    type: "REMOVE_EXPENSE",
    id: "123abc"
  });
});

test("should setup edit expense action object", () => {
  const action = editExpense("123abc", { note: "New note value" });
  expect(action).toEqual({
    type: "EDIT_EXPENSE",
    id: "123abc",
    updates: {
      note: "New note value"
    }
  });
});

test("should setup add expense action object with provided values", () => {
  const action = addExpense(expenses[2]);
  expect(action).toEqual({
    type: "ADD_EXPENSE",
    expense: expenses[2]
  });
});

/* This below is an ASYNCHRONOUS Test so we NEED a way to tell 'jest'(our testing Library) that THIS Test is
Asynchronous, and we do it by passing 'done' as the FIRST Argument of the Callback. In this way we're FORCING
'jest' to WAIT until the moment in time where we CALL 'done()' */
test("should add expense to database and store", done => {
  const store = createMockStore({});
  const expenseData = {
    description: "Mouse",
    amount: 3000,
    note: "This one is better",
    createdAt: 1000
  };

  /* Here below we're using "PROMISE CHAINING" that allows us to ATTACH a 'then'(or 'catch') CALL onto PROMISES 
  from elsewhere in our code. In our case we set up THIS code 'store.dispatch(startAddExpense(expendeData))' to 
  return a PROMISE(we've achieved this by adding a RETURN keyword BEFORE the 'dispatch' inside our 'expense.js'
  file, the one inside 'src/actions' folder), so NOW we can ADD a 'then' method on it, then INSIDE the 'then' 
  method we add our ASSERTIONS and in the end(so when our ASSERTIONS have been terminated) we can finally call 
  'done()' */
  store
    .dispatch(startAddExpense(expenseData))
    .then(() => {
      // This 'store.getActions()'(a method of 'redux-mock-store') below will return an ARRAY of ALL the ACTIONS
      const actions = store.getActions();
      // And this 'actions[0]' is the FIRST Action Object INSIDE the above 'actions' ARRAY we just defined
      expect(actions[0]).toEqual({
        type: "ADD_EXPENSE",
        expense: {
          id: expect.any(String),
          ...expenseData
        }
      });

      /* this '${actions[0].expense.id}' below is pretty much the UNIQUE ID that gets generated by Firebase, and
    we can use it to actually FETCH that Item */
      return database.ref(`expenses/${actions[0].expense.id}`).once("value");
    })
    // Here below we're CHAINING a 'then' method because ABOVE we're returning a PROMISE
    .then(snapshot => {
      expect(snapshot.val()).toEqual(expenseData);
      done();
    });
});

test("should add expense with defaults to database and store", done => {
  const store = createMockStore({});
  const expenseDefaults = {
    description: "",
    amount: 0,
    note: "",
    createdAt: 0
  };

  store
    .dispatch(startAddExpense({}))
    .then(() => {
      const actions = store.getActions();
      expect(actions[0]).toEqual({
        type: "ADD_EXPENSE",
        expense: {
          id: expect.any(String),
          ...expenseDefaults
        }
      });

      return database.ref(`expenses/${actions[0].expense.id}`).once("value");
    })

    .then(snapshot => {
      expect(snapshot.val()).toEqual(expenseDefaults);
      done();
    });
});

// test("should setup add expense action object with default values", () => {
//   const action = addExpense();
//   expect(action).toEqual({
//     type: "ADD_EXPENSE",
//     expense: {
//       id: expect.any(String),
//       description: "",
//       note: "",
//       amount: 0,
//       createdAt: 0
//     }
//   });
// });
